#include "../error.hpp"
#include "../ts_reader.hpp"

#include <iostream>
#include <set>
#include <sstream>
#include <vector>


// audio packets and payloads
namespace
{
	const std::vector<uint8_t> audioPacket1{ 0x47, 0x40, 0x22, 0x30, 0x01, 0x40, 0x00, 0x00, 0x01, 0xC0, 0x0A, 0xF5, 0x84, 0x80, 0x05, 0x21,
		                                     0x00, 0x37, 0x77, 0x41, 0xFF, 0xF1, 0x4C, 0x80, 0x04, 0x3F, 0xFC, 0xDE, 0x04, 0x00, 0x00, 0x6C,
		                                     0x69, 0x62, 0x66, 0x61, 0x61, 0x63, 0x20, 0x31, 0x2E, 0x32, 0x38, 0x00, 0x00, 0x42, 0x00, 0x93,
		                                     0x20, 0x04, 0x32, 0x00, 0x47, 0xFF, 0xF1, 0x4C, 0x80, 0x02, 0x1F, 0xFC, 0x21, 0x00, 0x49, 0x90,
		                                     0x02, 0x19, 0x00, 0x23, 0x80, 0xFF, 0xF1, 0x4C, 0x80, 0x02, 0x1F, 0xFC, 0x21, 0x00, 0x49, 0x90,
		                                     0x02, 0x19, 0x00, 0x23, 0x80, 0xFF, 0xF1, 0x4C, 0x80, 0x02, 0x1F, 0xFC, 0x21, 0x00, 0x49, 0x90,
		                                     0x02, 0x19, 0x00, 0x23, 0x80, 0xFF, 0xF1, 0x4C, 0x80, 0x02, 0x1F, 0xFC, 0x21, 0x00, 0x49, 0x90,
		                                     0x02, 0x19, 0x00, 0x23, 0x80, 0xFF, 0xF1, 0x4C, 0x80, 0x02, 0x1F, 0xFC, 0x21, 0x00, 0x49, 0x90,
		                                     0x02, 0x19, 0x00, 0x23, 0x80, 0xFF, 0xF1, 0x4C, 0x80, 0x02, 0x1F, 0xFC, 0x21, 0x00, 0x49, 0x90,
		                                     0x02, 0x19, 0x00, 0x23, 0x80, 0xFF, 0xF1, 0x4C, 0x80, 0x02, 0x1F, 0xFC, 0x21, 0x00, 0x49, 0x90,
		                                     0x02, 0x19, 0x00, 0x23, 0x80, 0xFF, 0xF1, 0x4C, 0x80, 0x02, 0x1F, 0xFC, 0x21, 0x00, 0x49, 0x90,
		                                     0x02, 0x19, 0x00, 0x23, 0x80, 0xFF, 0xF1, 0x4C, 0x80, 0x02, 0x1F, 0xFC };

	const std::vector<uint8_t> audioPayload1{ 0x00, 0x00, 0x01, 0xC0, 0x0A, 0xF5, 0x84, 0x80, 0x05, 0x21, 0x00, 0x37, 0x77, 0x41, 0xFF, 0xF1,
		                                      0x4C, 0x80, 0x04, 0x3F, 0xFC, 0xDE, 0x04, 0x00, 0x00, 0x6C, 0x69, 0x62, 0x66, 0x61, 0x61, 0x63,
		                                      0x20, 0x31, 0x2E, 0x32, 0x38, 0x00, 0x00, 0x42, 0x00, 0x93, 0x20, 0x04, 0x32, 0x00, 0x47, 0xFF,
		                                      0xF1, 0x4C, 0x80, 0x02, 0x1F, 0xFC, 0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80, 0xFF,
		                                      0xF1, 0x4C, 0x80, 0x02, 0x1F, 0xFC, 0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80, 0xFF,
		                                      0xF1, 0x4C, 0x80, 0x02, 0x1F, 0xFC, 0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80, 0xFF,
		                                      0xF1, 0x4C, 0x80, 0x02, 0x1F, 0xFC, 0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80, 0xFF,
		                                      0xF1, 0x4C, 0x80, 0x02, 0x1F, 0xFC, 0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80, 0xFF,
		                                      0xF1, 0x4C, 0x80, 0x02, 0x1F, 0xFC, 0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80, 0xFF,
		                                      0xF1, 0x4C, 0x80, 0x02, 0x1F, 0xFC, 0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80, 0xFF,
		                                      0xF1, 0x4C, 0x80, 0x02, 0x1F, 0xFC, 0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80, 0xFF,
		                                      0xF1, 0x4C, 0x80, 0x02, 0x1F, 0xFC };

	const std::vector<uint8_t> audioPacket2{ 0x47, 0x00, 0x22, 0x11, 0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80, 0xFF, 0xF1, 0x4C,
		                                     0x80, 0x02, 0x1F, 0xFC, 0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80, 0xFF, 0xF1, 0x4C,
		                                     0x80, 0x02, 0x1F, 0xFC, 0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80, 0xFF, 0xF1, 0x4C,
		                                     0x80, 0x02, 0x1F, 0xFC, 0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80, 0xFF, 0xF1, 0x4C,
		                                     0x80, 0x02, 0x1F, 0xFC, 0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80, 0xFF, 0xF1, 0x4C,
		                                     0x80, 0x02, 0x1F, 0xFC, 0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80, 0xFF, 0xF1, 0x4C,
		                                     0x80, 0x02, 0x1F, 0xFC, 0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80, 0xFF, 0xF1, 0x4C,
		                                     0x80, 0x02, 0x1F, 0xFC, 0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80, 0xFF, 0xF1, 0x4C,
		                                     0x80, 0x02, 0x1F, 0xFC, 0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80, 0xFF, 0xF1, 0x4C,
		                                     0x80, 0x02, 0x1F, 0xFC, 0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80, 0xFF, 0xF1, 0x4C,
		                                     0x80, 0x02, 0x1F, 0xFC, 0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80, 0xFF, 0xF1, 0x4C,
		                                     0x80, 0x02, 0x1F, 0xFC, 0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23 };

	const std::vector<uint8_t> audioPayload2{ 0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80, 0xFF, 0xF1, 0x4C, 0x80, 0x02, 0x1F, 0xFC,
		                                      0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80, 0xFF, 0xF1, 0x4C, 0x80, 0x02, 0x1F, 0xFC,
		                                      0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80, 0xFF, 0xF1, 0x4C, 0x80, 0x02, 0x1F, 0xFC,
		                                      0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80, 0xFF, 0xF1, 0x4C, 0x80, 0x02, 0x1F, 0xFC,
		                                      0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80, 0xFF, 0xF1, 0x4C, 0x80, 0x02, 0x1F, 0xFC,
		                                      0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80, 0xFF, 0xF1, 0x4C, 0x80, 0x02, 0x1F, 0xFC,
		                                      0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80, 0xFF, 0xF1, 0x4C, 0x80, 0x02, 0x1F, 0xFC,
		                                      0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80, 0xFF, 0xF1, 0x4C, 0x80, 0x02, 0x1F, 0xFC,
		                                      0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80, 0xFF, 0xF1, 0x4C, 0x80, 0x02, 0x1F, 0xFC,
		                                      0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80, 0xFF, 0xF1, 0x4C, 0x80, 0x02, 0x1F, 0xFC,
		                                      0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80, 0xFF, 0xF1, 0x4C, 0x80, 0x02, 0x1F, 0xFC,
		                                      0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23 };
}

// video packets and payloads
namespace
{
	const std::vector<uint8_t> videoPacket1{ 0x47, 0x40, 0x21, 0x30, 0x07, 0x50, 0x00, 0x06, 0xC7, 0xD7, 0x7E, 0x00, 0x00, 0x00, 0x01, 0xE0,
											 0x00, 0x00, 0x84, 0x80, 0x05, 0x21, 0x00, 0x37, 0x77, 0x41, 0x00, 0x00, 0x00, 0x01, 0x09, 0xF0,
											 0x00, 0x00, 0x00, 0x01, 0x67, 0x42, 0xC0, 0x14, 0xDB, 0x04, 0x04, 0xE8, 0x40, 0x00, 0xCB, 0x73,
											 0x40, 0x26, 0x25, 0xA0, 0x07, 0xC5, 0x0A, 0xB8, 0x00, 0x00, 0x00, 0x01, 0x68, 0xCA, 0x8C, 0xB2,
											 0x00, 0x00, 0x01, 0x06, 0x05, 0xFF, 0xFF, 0x66, 0xDC, 0x45, 0xE9, 0xBD, 0xE6, 0xD9, 0x48, 0xB7,
											 0x96, 0x2C, 0xD8, 0x20, 0xD9, 0x23, 0xEE, 0xEF, 0x78, 0x32, 0x36, 0x34, 0x20, 0x2D, 0x20, 0x63,
											 0x6F, 0x72, 0x65, 0x20, 0x31, 0x32, 0x30, 0x20, 0x72, 0x32, 0x31, 0x35, 0x31, 0x20, 0x61, 0x33,
											 0x66, 0x34, 0x34, 0x30, 0x37, 0x20, 0x2D, 0x20, 0x48, 0x2E, 0x32, 0x36, 0x34, 0x2F, 0x4D, 0x50,
											 0x45, 0x47, 0x2D, 0x34, 0x20, 0x41, 0x56, 0x43, 0x20, 0x63, 0x6F, 0x64, 0x65, 0x63, 0x20, 0x2D,
											 0x20, 0x43, 0x6F, 0x70, 0x79, 0x6C, 0x65, 0x66, 0x74, 0x20, 0x32, 0x30, 0x30, 0x33, 0x2D, 0x32,
											 0x30, 0x31, 0x31, 0x20, 0x2D, 0x20, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x77, 0x77, 0x77,
											 0x2E, 0x76, 0x69, 0x64, 0x65, 0x6F, 0x6C, 0x61, 0x6E, 0x2E, 0x6F, 0x72 };

	const std::vector<uint8_t> videoPayload1{ 0x00, 0x00, 0x01, 0xE0, 0x00, 0x00, 0x84, 0x80, 0x05, 0x21, 0x00, 0x37, 0x77, 0x41, 0x00, 0x00,
											  0x00, 0x01, 0x09, 0xF0, 0x00, 0x00, 0x00, 0x01, 0x67, 0x42, 0xC0, 0x14, 0xDB, 0x04, 0x04, 0xE8,
											  0x40, 0x00, 0xCB, 0x73, 0x40, 0x26, 0x25, 0xA0, 0x07, 0xC5, 0x0A, 0xB8, 0x00, 0x00, 0x00, 0x01,
											  0x68, 0xCA, 0x8C, 0xB2, 0x00, 0x00, 0x01, 0x06, 0x05, 0xFF, 0xFF, 0x66, 0xDC, 0x45, 0xE9, 0xBD,
											  0xE6, 0xD9, 0x48, 0xB7, 0x96, 0x2C, 0xD8, 0x20, 0xD9, 0x23, 0xEE, 0xEF, 0x78, 0x32, 0x36, 0x34,
											  0x20, 0x2D, 0x20, 0x63, 0x6F, 0x72, 0x65, 0x20, 0x31, 0x32, 0x30, 0x20, 0x72, 0x32, 0x31, 0x35,
											  0x31, 0x20, 0x61, 0x33, 0x66, 0x34, 0x34, 0x30, 0x37, 0x20, 0x2D, 0x20, 0x48, 0x2E, 0x32, 0x36,
											  0x34, 0x2F, 0x4D, 0x50, 0x45, 0x47, 0x2D, 0x34, 0x20, 0x41, 0x56, 0x43, 0x20, 0x63, 0x6F, 0x64,
											  0x65, 0x63, 0x20, 0x2D, 0x20, 0x43, 0x6F, 0x70, 0x79, 0x6C, 0x65, 0x66, 0x74, 0x20, 0x32, 0x30,
											  0x30, 0x33, 0x2D, 0x32, 0x30, 0x31, 0x31, 0x20, 0x2D, 0x20, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F,
											  0x2F, 0x77, 0x77, 0x77, 0x2E, 0x76, 0x69, 0x64, 0x65, 0x6F, 0x6C, 0x61, 0x6E, 0x2E, 0x6F, 0x72 };

	const std::vector<uint8_t> videoPacket2{ 0x47, 0x00, 0x21, 0x11, 0x67, 0x2F, 0x78, 0x32, 0x36, 0x34, 0x2E, 0x68, 0x74, 0x6D, 0x6C, 0x20,
											 0x2D, 0x20, 0x6F, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x73, 0x3A, 0x20, 0x63, 0x61, 0x62, 0x61, 0x63,
											 0x3D, 0x30, 0x20, 0x72, 0x65, 0x66, 0x3D, 0x32, 0x20, 0x64, 0x65, 0x62, 0x6C, 0x6F, 0x63, 0x6B,
											 0x3D, 0x31, 0x3A, 0x30, 0x3A, 0x30, 0x20, 0x61, 0x6E, 0x61, 0x6C, 0x79, 0x73, 0x65, 0x3D, 0x30,
											 0x78, 0x31, 0x3A, 0x30, 0x78, 0x31, 0x31, 0x31, 0x20, 0x6D, 0x65, 0x3D, 0x68, 0x65, 0x78, 0x20,
											 0x73, 0x75, 0x62, 0x6D, 0x65, 0x3D, 0x36, 0x20, 0x70, 0x73, 0x79, 0x3D, 0x31, 0x20, 0x70, 0x73,
											 0x79, 0x5F, 0x72, 0x64, 0x3D, 0x31, 0x2E, 0x30, 0x30, 0x3A, 0x30, 0x2E, 0x30, 0x30, 0x20, 0x6D,
											 0x69, 0x78, 0x65, 0x64, 0x5F, 0x72, 0x65, 0x66, 0x3D, 0x31, 0x20, 0x6D, 0x65, 0x5F, 0x72, 0x61,
											 0x6E, 0x67, 0x65, 0x3D, 0x31, 0x36, 0x20, 0x63, 0x68, 0x72, 0x6F, 0x6D, 0x61, 0x5F, 0x6D, 0x65,
											 0x3D, 0x31, 0x20, 0x74, 0x72, 0x65, 0x6C, 0x6C, 0x69, 0x73, 0x3D, 0x31, 0x20, 0x38, 0x78, 0x38,
											 0x64, 0x63, 0x74, 0x3D, 0x30, 0x20, 0x63, 0x71, 0x6D, 0x3D, 0x30, 0x20, 0x64, 0x65, 0x61, 0x64,
											 0x7A, 0x6F, 0x6E, 0x65, 0x3D, 0x32, 0x31, 0x2C, 0x31, 0x31, 0x20, 0x66 };

	const std::vector<uint8_t> videoPayload2{ 0x67, 0x2F, 0x78, 0x32, 0x36, 0x34, 0x2E, 0x68, 0x74, 0x6D, 0x6C, 0x20, 0x2D, 0x20, 0x6F, 0x70,
											  0x74, 0x69, 0x6F, 0x6E, 0x73, 0x3A, 0x20, 0x63, 0x61, 0x62, 0x61, 0x63, 0x3D, 0x30, 0x20, 0x72,
											  0x65, 0x66, 0x3D, 0x32, 0x20, 0x64, 0x65, 0x62, 0x6C, 0x6F, 0x63, 0x6B, 0x3D, 0x31, 0x3A, 0x30,
											  0x3A, 0x30, 0x20, 0x61, 0x6E, 0x61, 0x6C, 0x79, 0x73, 0x65, 0x3D, 0x30, 0x78, 0x31, 0x3A, 0x30,
											  0x78, 0x31, 0x31, 0x31, 0x20, 0x6D, 0x65, 0x3D, 0x68, 0x65, 0x78, 0x20, 0x73, 0x75, 0x62, 0x6D,
											  0x65, 0x3D, 0x36, 0x20, 0x70, 0x73, 0x79, 0x3D, 0x31, 0x20, 0x70, 0x73, 0x79, 0x5F, 0x72, 0x64,
											  0x3D, 0x31, 0x2E, 0x30, 0x30, 0x3A, 0x30, 0x2E, 0x30, 0x30, 0x20, 0x6D, 0x69, 0x78, 0x65, 0x64,
											  0x5F, 0x72, 0x65, 0x66, 0x3D, 0x31, 0x20, 0x6D, 0x65, 0x5F, 0x72, 0x61, 0x6E, 0x67, 0x65, 0x3D,
											  0x31, 0x36, 0x20, 0x63, 0x68, 0x72, 0x6F, 0x6D, 0x61, 0x5F, 0x6D, 0x65, 0x3D, 0x31, 0x20, 0x74,
											  0x72, 0x65, 0x6C, 0x6C, 0x69, 0x73, 0x3D, 0x31, 0x20, 0x38, 0x78, 0x38, 0x64, 0x63, 0x74, 0x3D,
											  0x30, 0x20, 0x63, 0x71, 0x6D, 0x3D, 0x30, 0x20, 0x64, 0x65, 0x61, 0x64, 0x7A, 0x6F, 0x6E, 0x65,
											  0x3D, 0x32, 0x31, 0x2C, 0x31, 0x31, 0x20, 0x66 };

	const std::vector<uint8_t> videoPacket3{ 0x47, 0x00, 0x21, 0x12, 0x61, 0x73, 0x74, 0x5F, 0x70, 0x73, 0x6B, 0x69, 0x70, 0x3D, 0x31, 0x20,
		                                     0x63, 0x68, 0x72, 0x6F, 0x6D, 0x61, 0x5F, 0x71, 0x70, 0x5F, 0x6F, 0x66, 0x66, 0x73, 0x65, 0x74,
		                                     0x3D, 0x2D, 0x32, 0x20, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x73, 0x3D, 0x36, 0x20, 0x73, 0x6C,
		                                     0x69, 0x63, 0x65, 0x64, 0x5F, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x73, 0x3D, 0x30, 0x20, 0x6E,
		                                     0x72, 0x3D, 0x30, 0x20, 0x64, 0x65, 0x63, 0x69, 0x6D, 0x61, 0x74, 0x65, 0x3D, 0x31, 0x20, 0x69,
		                                     0x6E, 0x74, 0x65, 0x72, 0x6C, 0x61, 0x63, 0x65, 0x64, 0x3D, 0x30, 0x20, 0x62, 0x6C, 0x75, 0x72,
		                                     0x61, 0x79, 0x5F, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x74, 0x3D, 0x30, 0x20, 0x63, 0x6F, 0x6E, 0x73,
		                                     0x74, 0x72, 0x61, 0x69, 0x6E, 0x65, 0x64, 0x5F, 0x69, 0x6E, 0x74, 0x72, 0x61, 0x3D, 0x30, 0x20,
		                                     0x62, 0x66, 0x72, 0x61, 0x6D, 0x65, 0x73, 0x3D, 0x30, 0x20, 0x77, 0x65, 0x69, 0x67, 0x68, 0x74,
		                                     0x70, 0x3D, 0x30, 0x20, 0x6B, 0x65, 0x79, 0x69, 0x6E, 0x74, 0x3D, 0x39, 0x36, 0x20, 0x6B, 0x65,
		                                     0x79, 0x69, 0x6E, 0x74, 0x5F, 0x6D, 0x69, 0x6E, 0x3D, 0x34, 0x38, 0x20, 0x73, 0x63, 0x65, 0x6E,
		                                     0x65, 0x63, 0x75, 0x74, 0x3D, 0x30, 0x20, 0x69, 0x6E, 0x74, 0x72, 0x61 };
}

// other packets
namespace
{
	const std::vector<uint8_t> patPacket{ 0x47, 0x40, 0x00, 0x10, 0x00, 0x00, 0xB0, 0x0D, 0x41, 0x57, 0xC1, 0x00, 0x00, 0x41, 0x57, 0xE0,
		                                  0x20, 0x9D, 0xE6, 0x30, 0x91, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		                                  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		                                  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		                                  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		                                  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		                                  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		                                  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		                                  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		                                  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		                                  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		                                  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };

	const std::vector<uint8_t> nullPacket{ 0x47, 0x1F, 0xFF, 0x10, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		                                   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		                                   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		                                   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		                                   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		                                   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		                                   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		                                   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		                                   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		                                   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		                                   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		                                   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };
}

namespace
{
	/// @brief Run one TsReader unit test.
	/// @returns true if test passed, false otherwise.
	bool runTest(const std::string& testName,
		         std::stringstream& input,
			     uint16_t expectedError,
		         const std::string& expectedPayload,
				 size_t expectedNumberOfPids)
	{
		std::cout << "Running TsReader." << testName << " ... ";

		bool result = true;
		Error error{ Error::OK, "" };
		std::ostringstream log;
		std::ostringstream payload;
		std::set<uint16_t> pids;
		auto handler = [&payload, &pids](const TsPayload& p)
		{
			payload.write(reinterpret_cast<const char*>(p.data), p.length);
			pids.insert(p.pid);
		};

		try
		{
			TsReader reader(input, log, handler);
			reader.readAll();
		}
		catch (const Error& err)
		{
			error = err;
		}
		catch (const std::exception& e)
		{
			result = false;
			log << "Unexpected exception caught: " << e.what() << std::endl;
		}

		if (error.code() != expectedError)
		{
			result = false;
			if (expectedError == Error::OK)
				log << "Unexpected exception caught: " << error.message() << std::endl;
			else
				log << "No expected exception caught" << std::endl;
		}
		if (payload.str() != expectedPayload)
		{
			result = false;
			log << "Produced payload differs from expected" << std::endl;
		}
		if (pids.size() != expectedNumberOfPids)
		{
			result = false;
			log << "Got " << pids.size() << " pids instead of " << expectedNumberOfPids << std::endl;
		}

		std::cout << (result ? "OK" : "FAIL") << std::endl;
		if (!result)
			std::cout << log.str();
		return result;
	}
}

/// @brief Run all TsReader unit tests.
/// @returns Number of failed tests.
uint16_t testTsReader()
{
	uint16_t failures = 0;

	// 1 video packet, start of elementary stream
	std::stringstream input;
	input.write(reinterpret_cast<const char*>(videoPacket1.data()), videoPacket1.size());
	std::ostringstream payload;
	payload.write(reinterpret_cast<const char*>(videoPayload1.data()), videoPayload1.size());
	failures += 1 - runTest("readAll_Video1Packet_OK", input, Error::OK, payload.str(), 1);

	// 2 video packets, start of elementary stream and continuation
	input.swap(std::stringstream());
	input.write(reinterpret_cast<const char*>(videoPacket1.data()), videoPacket1.size());
	input.write(reinterpret_cast<const char*>(videoPacket2.data()), videoPacket2.size());
	payload.swap(std::ostringstream());
	payload.write(reinterpret_cast<const char*>(videoPayload1.data()), videoPayload1.size());
	payload.write(reinterpret_cast<const char*>(videoPayload2.data()), videoPayload2.size());
	failures += 1 - runTest("readAll_Video2Packets_OK", input, Error::OK, payload.str(), 1);

	// 3 video packets, start of TS is not start of ES
	input.swap(std::stringstream());
	input.write(reinterpret_cast<const char*>(videoPacket3.data()), videoPacket3.size());
	input.write(reinterpret_cast<const char*>(videoPacket1.data()), videoPacket1.size());
	input.write(reinterpret_cast<const char*>(videoPacket2.data()), videoPacket2.size());
	payload.swap(std::ostringstream());
	payload.write(reinterpret_cast<const char*>(videoPayload1.data()), videoPayload1.size());
	payload.write(reinterpret_cast<const char*>(videoPayload2.data()), videoPayload2.size());
	failures += 1 - runTest("readAll_TsStartNotEsStart_OK", input, Error::OK, payload.str(), 1);

	// PAT packet and video packet
	input.swap(std::stringstream());
	input.write(reinterpret_cast<const char*>(patPacket.data()), patPacket.size());
	input.write(reinterpret_cast<const char*>(videoPacket1.data()), videoPacket1.size());
	payload.swap(std::ostringstream());
	payload.write(reinterpret_cast<const char*>(videoPayload1.data()), videoPayload1.size());
	failures += 1 - runTest("readAll_PatAndVideoPackets_OK", input, Error::OK, payload.str(), 1);

	// null packet and video packet
	input.swap(std::stringstream());
	input.write(reinterpret_cast<const char*>(nullPacket.data()), nullPacket.size());
	input.write(reinterpret_cast<const char*>(videoPacket1.data()), videoPacket1.size());
	payload.swap(std::ostringstream());
	payload.write(reinterpret_cast<const char*>(videoPayload1.data()), videoPayload1.size());
	failures += 1 - runTest("readAll_NullAndVideoPackets_OK", input, Error::OK, payload.str(), 1);

	// 1 audio packet, start of elementary stream
	input.swap(std::stringstream());
	input.write(reinterpret_cast<const char*>(audioPacket1.data()), audioPacket1.size());
	payload.swap(std::ostringstream());
	payload.write(reinterpret_cast<const char*>(audioPayload1.data()), audioPayload1.size());
	failures += 1 - runTest("readAll_Audio1Packet_OK", input, Error::OK, payload.str(), 1);

	// 2 audio packets, start of elementary stream and continuation
	input.swap(std::stringstream());
	input.write(reinterpret_cast<const char*>(audioPacket1.data()), audioPacket1.size());
	input.write(reinterpret_cast<const char*>(audioPacket2.data()), audioPacket2.size());
	payload.swap(std::ostringstream());
	payload.write(reinterpret_cast<const char*>(audioPayload1.data()), audioPayload1.size());
	payload.write(reinterpret_cast<const char*>(audioPayload2.data()), audioPayload2.size());
	failures += 1 - runTest("readAll_Audio2Packets_OK", input, Error::OK, payload.str(), 1);

	// 2 elementary streams
	input.swap(std::stringstream());
	input.write(reinterpret_cast<const char*>(videoPacket1.data()), videoPacket1.size());
	input.write(reinterpret_cast<const char*>(audioPacket1.data()), audioPacket1.size());
	input.write(reinterpret_cast<const char*>(videoPacket2.data()), videoPacket2.size());
	input.write(reinterpret_cast<const char*>(audioPacket2.data()), audioPacket2.size());
	payload.swap(std::ostringstream());
	payload.write(reinterpret_cast<const char*>(videoPayload1.data()), videoPayload1.size());
	payload.write(reinterpret_cast<const char*>(audioPayload1.data()), audioPayload1.size());
	payload.write(reinterpret_cast<const char*>(videoPayload2.data()), videoPayload2.size());
	payload.write(reinterpret_cast<const char*>(audioPayload2.data()), audioPayload2.size());
	failures += 1 - runTest("readAll_AudioAndVideoPackets_OK", input, Error::OK, payload.str(), 2);

	// short input
	input.swap(std::stringstream());
	input.write(reinterpret_cast<const char*>(videoPacket3.data() + 10), videoPacket3.size() / 2);
	failures += 1 - runTest("readAll_ShortInput_OK", input, Error::OK, "", 0);

	// empty input
	input.swap(std::stringstream());
	failures += 1 - runTest("readAll_EmptyInput_OK", input, Error::OK, "", 0);

	// not a TS stream
	input.swap(std::stringstream());
	input.write(reinterpret_cast<const char*>(videoPacket3.data() + 10), videoPacket3.size() - 20);
	input.write(reinterpret_cast<const char*>(videoPacket1.data() + 10), videoPacket1.size() - 20);
	failures += 1 - runTest("readAll_NotTsStream_OK", input, Error::OK, "", 0);

	// corrupted TS start with sync byte
	input.swap(std::stringstream());
	input.write(reinterpret_cast<const char*>(videoPacket3.data()), videoPacket3.size() / 2);
	input.write(reinterpret_cast<const char*>(videoPacket1.data()), videoPacket1.size());
	input.write(reinterpret_cast<const char*>(videoPacket2.data()), videoPacket2.size());
	payload.swap(std::ostringstream());
	payload.write(reinterpret_cast<const char*>(videoPayload1.data()), videoPayload1.size());
	payload.write(reinterpret_cast<const char*>(videoPayload2.data()), videoPayload2.size());
	failures += 1 - runTest("readAll_CorruptedTsStartWithSyncByte_OK", input, Error::OK, payload.str(), 1);

	// corrupted TS start without sync byte
	input.swap(std::stringstream());
	input.write(reinterpret_cast<const char*>(videoPacket3.data() + 10), videoPacket3.size() / 2);
	input.write(reinterpret_cast<const char*>(videoPacket1.data()), videoPacket1.size());
	input.write(reinterpret_cast<const char*>(videoPacket2.data()), videoPacket2.size());
	payload.swap(std::ostringstream());
	payload.write(reinterpret_cast<const char*>(videoPayload1.data()), videoPayload1.size());
	payload.write(reinterpret_cast<const char*>(videoPayload2.data()), videoPayload2.size());
	failures += 1 - runTest("readAll_CorruptedTsStartWithoutSyncByte_OK", input, Error::OK, payload.str(), 1);

	// corrupted TS end with sync byte
	input.swap(std::stringstream());
	input.write(reinterpret_cast<const char*>(videoPacket1.data()), videoPacket1.size());
	input.write(reinterpret_cast<const char*>(audioPacket1.data()), audioPacket1.size());
	input.write(reinterpret_cast<const char*>(videoPacket2.data()), videoPacket2.size() / 2);
	payload.swap(std::ostringstream());
	payload.write(reinterpret_cast<const char*>(videoPayload1.data()), videoPayload1.size());
	payload.write(reinterpret_cast<const char*>(audioPayload1.data()), audioPayload1.size());
	failures += 1 - runTest("readAll_CorruptedTsEndWithSyncByte_OK", input, Error::OK, payload.str(), 2);

	// corrupted TS end without sync byte, last packet preceeding garbage is lost
	input.swap(std::stringstream());
	input.write(reinterpret_cast<const char*>(videoPacket1.data()), videoPacket1.size());
	input.write(reinterpret_cast<const char*>(audioPacket1.data()), audioPacket1.size());
	input.write(reinterpret_cast<const char*>(videoPacket2.data() + 10), videoPacket2.size() / 2);
	payload.swap(std::ostringstream());
	payload.write(reinterpret_cast<const char*>(videoPayload1.data()), videoPayload1.size());
	failures += 1 - runTest("readAll_CorruptedTsEndWithoutSyncByte_OK", input, Error::OK, payload.str(), 1);

	// corrupted TS middle with sync byte
	input.swap(std::stringstream());
	input.write(reinterpret_cast<const char*>(videoPacket1.data()), videoPacket1.size());
	input.write(reinterpret_cast<const char*>(videoPacket3.data()), videoPacket3.size() / 2);
	input.write(reinterpret_cast<const char*>(videoPacket2.data()), videoPacket2.size());
	payload.swap(std::ostringstream());
	payload.write(reinterpret_cast<const char*>(videoPayload1.data()), videoPayload1.size());
	payload.write(reinterpret_cast<const char*>(videoPayload2.data()), videoPayload2.size());
	failures += 1 - runTest("readAll_CorruptedTsMiddleWithSyncByte_OK", input, Error::OK, payload.str(), 1);

	// corrupted TS middle without sync byte, last packet preceeding garbage is lost
	input.swap(std::stringstream());
	input.write(reinterpret_cast<const char*>(videoPacket1.data()), videoPacket1.size());
	input.write(reinterpret_cast<const char*>(videoPacket3.data() + 10), videoPacket3.size() / 2);
	input.write(reinterpret_cast<const char*>(videoPacket2.data()), videoPacket2.size());
	failures += 1 - runTest("readAll_CorruptedTsMiddleWithoutSyncByte_OK", input, Error::OK, "", 0);

	// Bad input
	input.swap(std::stringstream());
	input.peek();
	failures += 1 - runTest("ctor_BadInput_Exception", input, Error::CONSTRUCTION_ERROR, "", 0);

	return failures;
}
