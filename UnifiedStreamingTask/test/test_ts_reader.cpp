#include "../error.hpp"
#include "../ts_reader.hpp"

#include <iostream>
#include <set>
#include <sstream>
#include <vector>


// audio packets and payloads
namespace
{
    const std::vector<uint8_t> audioPacket1{ 0x47, 0x40, 0x22, 0x30, 0x01, 0x40, 0x00, 0x00, 0x01, 0xC0, 0x0A, 0xF5, 0x84, 0x80, 0x05, 0x21,
                                             0x00, 0x37, 0x77, 0x41, 0xFF, 0xF1, 0x4C, 0x80, 0x04, 0x3F, 0xFC, 0xDE, 0x04, 0x00, 0x00, 0x6C,
                                             0x69, 0x62, 0x66, 0x61, 0x61, 0x63, 0x20, 0x31, 0x2E, 0x32, 0x38, 0x00, 0x00, 0x42, 0x00, 0x93,
                                             0x20, 0x04, 0x32, 0x00, 0x47, 0xFF, 0xF1, 0x4C, 0x80, 0x02, 0x1F, 0xFC, 0x21, 0x00, 0x49, 0x90,
                                             0x02, 0x19, 0x00, 0x23, 0x80, 0xFF, 0xF1, 0x4C, 0x80, 0x02, 0x1F, 0xFC, 0x21, 0x00, 0x49, 0x90,
                                             0x02, 0x19, 0x00, 0x23, 0x80, 0xFF, 0xF1, 0x4C, 0x80, 0x02, 0x1F, 0xFC, 0x21, 0x00, 0x49, 0x90,
                                             0x02, 0x19, 0x00, 0x23, 0x80, 0xFF, 0xF1, 0x4C, 0x80, 0x02, 0x1F, 0xFC, 0x21, 0x00, 0x49, 0x90,
                                             0x02, 0x19, 0x00, 0x23, 0x80, 0xFF, 0xF1, 0x4C, 0x80, 0x02, 0x1F, 0xFC, 0x21, 0x00, 0x49, 0x90,
                                             0x02, 0x19, 0x00, 0x23, 0x80, 0xFF, 0xF1, 0x4C, 0x80, 0x02, 0x1F, 0xFC, 0x21, 0x00, 0x49, 0x90,
                                             0x02, 0x19, 0x00, 0x23, 0x80, 0xFF, 0xF1, 0x4C, 0x80, 0x02, 0x1F, 0xFC, 0x21, 0x00, 0x49, 0x90,
                                             0x02, 0x19, 0x00, 0x23, 0x80, 0xFF, 0xF1, 0x4C, 0x80, 0x02, 0x1F, 0xFC, 0x21, 0x00, 0x49, 0x90,
                                             0x02, 0x19, 0x00, 0x23, 0x80, 0xFF, 0xF1, 0x4C, 0x80, 0x02, 0x1F, 0xFC };

    const std::vector<uint8_t> audioPayload1{ 0x00, 0x00, 0x01, 0xC0, 0x0A, 0xF5, 0x84, 0x80, 0x05, 0x21, 0x00, 0x37, 0x77, 0x41, 0xFF, 0xF1,
                                              0x4C, 0x80, 0x04, 0x3F, 0xFC, 0xDE, 0x04, 0x00, 0x00, 0x6C, 0x69, 0x62, 0x66, 0x61, 0x61, 0x63,
                                              0x20, 0x31, 0x2E, 0x32, 0x38, 0x00, 0x00, 0x42, 0x00, 0x93, 0x20, 0x04, 0x32, 0x00, 0x47, 0xFF,
                                              0xF1, 0x4C, 0x80, 0x02, 0x1F, 0xFC, 0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80, 0xFF,
                                              0xF1, 0x4C, 0x80, 0x02, 0x1F, 0xFC, 0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80, 0xFF,
                                              0xF1, 0x4C, 0x80, 0x02, 0x1F, 0xFC, 0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80, 0xFF,
                                              0xF1, 0x4C, 0x80, 0x02, 0x1F, 0xFC, 0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80, 0xFF,
                                              0xF1, 0x4C, 0x80, 0x02, 0x1F, 0xFC, 0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80, 0xFF,
                                              0xF1, 0x4C, 0x80, 0x02, 0x1F, 0xFC, 0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80, 0xFF,
                                              0xF1, 0x4C, 0x80, 0x02, 0x1F, 0xFC, 0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80, 0xFF,
                                              0xF1, 0x4C, 0x80, 0x02, 0x1F, 0xFC, 0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80, 0xFF,
                                              0xF1, 0x4C, 0x80, 0x02, 0x1F, 0xFC };

    const std::vector<uint8_t> audioPacket2{ 0x47, 0x00, 0x22, 0x11, 0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80, 0xFF, 0xF1, 0x4C,
                                             0x80, 0x02, 0x1F, 0xFC, 0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80, 0xFF, 0xF1, 0x4C,
                                             0x80, 0x02, 0x1F, 0xFC, 0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80, 0xFF, 0xF1, 0x4C,
                                             0x80, 0x02, 0x1F, 0xFC, 0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80, 0xFF, 0xF1, 0x4C,
                                             0x80, 0x02, 0x1F, 0xFC, 0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80, 0xFF, 0xF1, 0x4C,
                                             0x80, 0x02, 0x1F, 0xFC, 0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80, 0xFF, 0xF1, 0x4C,
                                             0x80, 0x02, 0x1F, 0xFC, 0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80, 0xFF, 0xF1, 0x4C,
                                             0x80, 0x02, 0x1F, 0xFC, 0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80, 0xFF, 0xF1, 0x4C,
                                             0x80, 0x02, 0x1F, 0xFC, 0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80, 0xFF, 0xF1, 0x4C,
                                             0x80, 0x02, 0x1F, 0xFC, 0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80, 0xFF, 0xF1, 0x4C,
                                             0x80, 0x02, 0x1F, 0xFC, 0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80, 0xFF, 0xF1, 0x4C,
                                             0x80, 0x02, 0x1F, 0xFC, 0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23 };

    const std::vector<uint8_t> audioPayload2{ 0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80, 0xFF, 0xF1, 0x4C, 0x80, 0x02, 0x1F, 0xFC,
                                              0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80, 0xFF, 0xF1, 0x4C, 0x80, 0x02, 0x1F, 0xFC,
                                              0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80, 0xFF, 0xF1, 0x4C, 0x80, 0x02, 0x1F, 0xFC,
                                              0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80, 0xFF, 0xF1, 0x4C, 0x80, 0x02, 0x1F, 0xFC,
                                              0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80, 0xFF, 0xF1, 0x4C, 0x80, 0x02, 0x1F, 0xFC,
                                              0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80, 0xFF, 0xF1, 0x4C, 0x80, 0x02, 0x1F, 0xFC,
                                              0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80, 0xFF, 0xF1, 0x4C, 0x80, 0x02, 0x1F, 0xFC,
                                              0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80, 0xFF, 0xF1, 0x4C, 0x80, 0x02, 0x1F, 0xFC,
                                              0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80, 0xFF, 0xF1, 0x4C, 0x80, 0x02, 0x1F, 0xFC,
                                              0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80, 0xFF, 0xF1, 0x4C, 0x80, 0x02, 0x1F, 0xFC,
                                              0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80, 0xFF, 0xF1, 0x4C, 0x80, 0x02, 0x1F, 0xFC,
                                              0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23 };
}

// video packets and payloads
namespace
{
    const std::vector<uint8_t> videoPacket1{ 0x47, 0x40, 0x21, 0x30, 0x07, 0x50, 0x00, 0x06, 0xC7, 0xD7, 0x7E, 0x00, 0x00, 0x00, 0x01, 0xE0,
                                             0x00, 0x00, 0x84, 0x80, 0x05, 0x21, 0x00, 0x37, 0x77, 0x41, 0x00, 0x00, 0x00, 0x01, 0x09, 0xF0,
                                             0x00, 0x00, 0x00, 0x01, 0x67, 0x42, 0xC0, 0x14, 0xDB, 0x04, 0x04, 0xE8, 0x40, 0x00, 0xCB, 0x73,
                                             0x40, 0x26, 0x25, 0xA0, 0x07, 0xC5, 0x0A, 0xB8, 0x00, 0x00, 0x00, 0x01, 0x68, 0xCA, 0x8C, 0xB2,
                                             0x00, 0x00, 0x01, 0x06, 0x05, 0xFF, 0xFF, 0x66, 0xDC, 0x45, 0xE9, 0xBD, 0xE6, 0xD9, 0x48, 0xB7,
                                             0x96, 0x2C, 0xD8, 0x20, 0xD9, 0x23, 0xEE, 0xEF, 0x78, 0x32, 0x36, 0x34, 0x20, 0x2D, 0x20, 0x63,
                                             0x6F, 0x72, 0x65, 0x20, 0x31, 0x32, 0x30, 0x20, 0x72, 0x32, 0x31, 0x35, 0x31, 0x20, 0x61, 0x33,
                                             0x66, 0x34, 0x34, 0x30, 0x37, 0x20, 0x2D, 0x20, 0x48, 0x2E, 0x32, 0x36, 0x34, 0x2F, 0x4D, 0x50,
                                             0x45, 0x47, 0x2D, 0x34, 0x20, 0x41, 0x56, 0x43, 0x20, 0x63, 0x6F, 0x64, 0x65, 0x63, 0x20, 0x2D,
                                             0x20, 0x43, 0x6F, 0x70, 0x79, 0x6C, 0x65, 0x66, 0x74, 0x20, 0x32, 0x30, 0x30, 0x33, 0x2D, 0x32,
                                             0x30, 0x31, 0x31, 0x20, 0x2D, 0x20, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x77, 0x77, 0x77,
                                             0x2E, 0x76, 0x69, 0x64, 0x65, 0x6F, 0x6C, 0x61, 0x6E, 0x2E, 0x6F, 0x72 };

    const std::vector<uint8_t> videoPayload1{ 0x00, 0x00, 0x01, 0xE0, 0x00, 0x00, 0x84, 0x80, 0x05, 0x21, 0x00, 0x37, 0x77, 0x41, 0x00, 0x00,
                                              0x00, 0x01, 0x09, 0xF0, 0x00, 0x00, 0x00, 0x01, 0x67, 0x42, 0xC0, 0x14, 0xDB, 0x04, 0x04, 0xE8,
                                              0x40, 0x00, 0xCB, 0x73, 0x40, 0x26, 0x25, 0xA0, 0x07, 0xC5, 0x0A, 0xB8, 0x00, 0x00, 0x00, 0x01,
                                              0x68, 0xCA, 0x8C, 0xB2, 0x00, 0x00, 0x01, 0x06, 0x05, 0xFF, 0xFF, 0x66, 0xDC, 0x45, 0xE9, 0xBD,
                                              0xE6, 0xD9, 0x48, 0xB7, 0x96, 0x2C, 0xD8, 0x20, 0xD9, 0x23, 0xEE, 0xEF, 0x78, 0x32, 0x36, 0x34,
                                              0x20, 0x2D, 0x20, 0x63, 0x6F, 0x72, 0x65, 0x20, 0x31, 0x32, 0x30, 0x20, 0x72, 0x32, 0x31, 0x35,
                                              0x31, 0x20, 0x61, 0x33, 0x66, 0x34, 0x34, 0x30, 0x37, 0x20, 0x2D, 0x20, 0x48, 0x2E, 0x32, 0x36,
                                              0x34, 0x2F, 0x4D, 0x50, 0x45, 0x47, 0x2D, 0x34, 0x20, 0x41, 0x56, 0x43, 0x20, 0x63, 0x6F, 0x64,
                                              0x65, 0x63, 0x20, 0x2D, 0x20, 0x43, 0x6F, 0x70, 0x79, 0x6C, 0x65, 0x66, 0x74, 0x20, 0x32, 0x30,
                                              0x30, 0x33, 0x2D, 0x32, 0x30, 0x31, 0x31, 0x20, 0x2D, 0x20, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F,
                                              0x2F, 0x77, 0x77, 0x77, 0x2E, 0x76, 0x69, 0x64, 0x65, 0x6F, 0x6C, 0x61, 0x6E, 0x2E, 0x6F, 0x72 };

    const std::vector<uint8_t> videoPacket2{ 0x47, 0x00, 0x21, 0x11, 0x67, 0x2F, 0x78, 0x32, 0x36, 0x34, 0x2E, 0x68, 0x74, 0x6D, 0x6C, 0x20,
                                             0x2D, 0x20, 0x6F, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x73, 0x3A, 0x20, 0x63, 0x61, 0x62, 0x61, 0x63,
                                             0x3D, 0x30, 0x20, 0x72, 0x65, 0x66, 0x3D, 0x32, 0x20, 0x64, 0x65, 0x62, 0x6C, 0x6F, 0x63, 0x6B,
                                             0x3D, 0x31, 0x3A, 0x30, 0x3A, 0x30, 0x20, 0x61, 0x6E, 0x61, 0x6C, 0x79, 0x73, 0x65, 0x3D, 0x30,
                                             0x78, 0x31, 0x3A, 0x30, 0x78, 0x31, 0x31, 0x31, 0x20, 0x6D, 0x65, 0x3D, 0x68, 0x65, 0x78, 0x20,
                                             0x73, 0x75, 0x62, 0x6D, 0x65, 0x3D, 0x36, 0x20, 0x70, 0x73, 0x79, 0x3D, 0x31, 0x20, 0x70, 0x73,
                                             0x79, 0x5F, 0x72, 0x64, 0x3D, 0x31, 0x2E, 0x30, 0x30, 0x3A, 0x30, 0x2E, 0x30, 0x30, 0x20, 0x6D,
                                             0x69, 0x78, 0x65, 0x64, 0x5F, 0x72, 0x65, 0x66, 0x3D, 0x31, 0x20, 0x6D, 0x65, 0x5F, 0x72, 0x61,
                                             0x6E, 0x67, 0x65, 0x3D, 0x31, 0x36, 0x20, 0x63, 0x68, 0x72, 0x6F, 0x6D, 0x61, 0x5F, 0x6D, 0x65,
                                             0x3D, 0x31, 0x20, 0x74, 0x72, 0x65, 0x6C, 0x6C, 0x69, 0x73, 0x3D, 0x31, 0x20, 0x38, 0x78, 0x38,
                                             0x64, 0x63, 0x74, 0x3D, 0x30, 0x20, 0x63, 0x71, 0x6D, 0x3D, 0x30, 0x20, 0x64, 0x65, 0x61, 0x64,
                                             0x7A, 0x6F, 0x6E, 0x65, 0x3D, 0x32, 0x31, 0x2C, 0x31, 0x31, 0x20, 0x66 };

    const std::vector<uint8_t> videoPayload2{ 0x67, 0x2F, 0x78, 0x32, 0x36, 0x34, 0x2E, 0x68, 0x74, 0x6D, 0x6C, 0x20, 0x2D, 0x20, 0x6F, 0x70,
                                              0x74, 0x69, 0x6F, 0x6E, 0x73, 0x3A, 0x20, 0x63, 0x61, 0x62, 0x61, 0x63, 0x3D, 0x30, 0x20, 0x72,
                                              0x65, 0x66, 0x3D, 0x32, 0x20, 0x64, 0x65, 0x62, 0x6C, 0x6F, 0x63, 0x6B, 0x3D, 0x31, 0x3A, 0x30,
                                              0x3A, 0x30, 0x20, 0x61, 0x6E, 0x61, 0x6C, 0x79, 0x73, 0x65, 0x3D, 0x30, 0x78, 0x31, 0x3A, 0x30,
                                              0x78, 0x31, 0x31, 0x31, 0x20, 0x6D, 0x65, 0x3D, 0x68, 0x65, 0x78, 0x20, 0x73, 0x75, 0x62, 0x6D,
                                              0x65, 0x3D, 0x36, 0x20, 0x70, 0x73, 0x79, 0x3D, 0x31, 0x20, 0x70, 0x73, 0x79, 0x5F, 0x72, 0x64,
                                              0x3D, 0x31, 0x2E, 0x30, 0x30, 0x3A, 0x30, 0x2E, 0x30, 0x30, 0x20, 0x6D, 0x69, 0x78, 0x65, 0x64,
                                              0x5F, 0x72, 0x65, 0x66, 0x3D, 0x31, 0x20, 0x6D, 0x65, 0x5F, 0x72, 0x61, 0x6E, 0x67, 0x65, 0x3D,
                                              0x31, 0x36, 0x20, 0x63, 0x68, 0x72, 0x6F, 0x6D, 0x61, 0x5F, 0x6D, 0x65, 0x3D, 0x31, 0x20, 0x74,
                                              0x72, 0x65, 0x6C, 0x6C, 0x69, 0x73, 0x3D, 0x31, 0x20, 0x38, 0x78, 0x38, 0x64, 0x63, 0x74, 0x3D,
                                              0x30, 0x20, 0x63, 0x71, 0x6D, 0x3D, 0x30, 0x20, 0x64, 0x65, 0x61, 0x64, 0x7A, 0x6F, 0x6E, 0x65,
                                              0x3D, 0x32, 0x31, 0x2C, 0x31, 0x31, 0x20, 0x66 };

    const std::vector<uint8_t> videoPacket3{ 0x47, 0x00, 0x21, 0x12, 0x61, 0x73, 0x74, 0x5F, 0x70, 0x73, 0x6B, 0x69, 0x70, 0x3D, 0x31, 0x20,
                                             0x63, 0x68, 0x72, 0x6F, 0x6D, 0x61, 0x5F, 0x71, 0x70, 0x5F, 0x6F, 0x66, 0x66, 0x73, 0x65, 0x74,
                                             0x3D, 0x2D, 0x32, 0x20, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x73, 0x3D, 0x36, 0x20, 0x73, 0x6C,
                                             0x69, 0x63, 0x65, 0x64, 0x5F, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x73, 0x3D, 0x30, 0x20, 0x6E,
                                             0x72, 0x3D, 0x30, 0x20, 0x64, 0x65, 0x63, 0x69, 0x6D, 0x61, 0x74, 0x65, 0x3D, 0x31, 0x20, 0x69,
                                             0x6E, 0x74, 0x65, 0x72, 0x6C, 0x61, 0x63, 0x65, 0x64, 0x3D, 0x30, 0x20, 0x62, 0x6C, 0x75, 0x72,
                                             0x61, 0x79, 0x5F, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x74, 0x3D, 0x30, 0x20, 0x63, 0x6F, 0x6E, 0x73,
                                             0x74, 0x72, 0x61, 0x69, 0x6E, 0x65, 0x64, 0x5F, 0x69, 0x6E, 0x74, 0x72, 0x61, 0x3D, 0x30, 0x20,
                                             0x62, 0x66, 0x72, 0x61, 0x6D, 0x65, 0x73, 0x3D, 0x30, 0x20, 0x77, 0x65, 0x69, 0x67, 0x68, 0x74,
                                             0x70, 0x3D, 0x30, 0x20, 0x6B, 0x65, 0x79, 0x69, 0x6E, 0x74, 0x3D, 0x39, 0x36, 0x20, 0x6B, 0x65,
                                             0x79, 0x69, 0x6E, 0x74, 0x5F, 0x6D, 0x69, 0x6E, 0x3D, 0x34, 0x38, 0x20, 0x73, 0x63, 0x65, 0x6E,
                                             0x65, 0x63, 0x75, 0x74, 0x3D, 0x30, 0x20, 0x69, 0x6E, 0x74, 0x72, 0x61 };
}

// other packets
namespace
{
    const std::vector<uint8_t> patPacket{ 0x47, 0x40, 0x00, 0x10, 0x00, 0x00, 0xB0, 0x0D, 0x41, 0x57, 0xC1, 0x00, 0x00, 0x41, 0x57, 0xE0,
                                          0x20, 0x9D, 0xE6, 0x30, 0x91, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };

    const std::vector<uint8_t> patPayload{ 0x00, 0x00, 0xB0, 0x0D, 0x41, 0x57, 0xC1, 0x00, 0x00, 0x41, 0x57, 0xE0, 0x20, 0x9D, 0xE6, 0x30,
                                           0x91, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                                           0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                                           0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                                           0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                                           0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                                           0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                                           0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                                           0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                                           0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                                           0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                                           0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };

    const std::vector<uint8_t> nullPacket{ 0x47, 0x1F, 0xFF, 0x10, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                                           0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                                           0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                                           0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                                           0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                                           0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                                           0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                                           0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                                           0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                                           0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                                           0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                                           0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };
}

namespace
{
    /// @brief Run one TsReader unit test.
    /// @returns true if test passed, false otherwise.
    bool runTest(const std::string& testName,
                 std::stringstream& input,
                 uint16_t expectedError,
                 const std::string& expectedPayload,
                 size_t expectedNumberOfPids)
    {
        std::cout << "Running TsReader." << testName << " ... ";

        bool result = true;
        Error error{ Error::OK, "" };
        std::ostringstream log;
        std::ostringstream payload;
        std::set<uint16_t> pids;
        auto handler = [&payload, &pids](const TsPayload& p)
        {
            payload.write(reinterpret_cast<const char*>(p.data), p.size);
            pids.insert(p.pid);
        };

        try
        {
            TsReader reader(input, log, handler);
            reader.readAll();
        }
        catch (const Error& err)
        {
            error = err;
        }
        catch (const std::exception& e)
        {
            result = false;
            log << "Unexpected exception caught: " << e.what() << std::endl;
        }

        if (error.code() != expectedError)
        {
            result = false;
            if (expectedError == Error::OK)
                log << "Unexpected exception caught: " << error.message() << std::endl;
            else
                log << "No expected exception caught" << std::endl;
        }
        if (payload.str() != expectedPayload)
        {
            result = false;
            log << "Produced payload differs from expected" << std::endl;
        }
        if (pids.size() != expectedNumberOfPids)
        {
            result = false;
            log << "Got " << pids.size() << " pids instead of " << expectedNumberOfPids << std::endl;
        }

        std::cout << (result ? "OK" : "FAIL") << std::endl;
        if (!result)
            std::cout << log.str();
        return result;
    }
}

/// @brief Run all TsReader unit tests.
/// @returns Number of failed tests.
uint16_t testTsReader()
{
    uint16_t failures = 0;

    // Bad input
    {
        std::stringstream input;
        input.peek();
        failures += 1 - runTest("ctor_BadInput_Exception", input, Error::CONSTRUCTION_ERROR, "", 0);
    }

    // 1 video packet, start of elementary stream
    {
        std::stringstream input;
        input.write(reinterpret_cast<const char*>(videoPacket1.data()), videoPacket1.size());
        std::ostringstream payload;
        payload.write(reinterpret_cast<const char*>(videoPayload1.data()), videoPayload1.size());
        failures += 1 - runTest("readAll_Video1Packet_OK", input, Error::OK, payload.str(), 1);
    }

    // 2 video packets, start of elementary stream and continuation
    {
        std::stringstream input;
        input.write(reinterpret_cast<const char*>(videoPacket1.data()), videoPacket1.size());
        input.write(reinterpret_cast<const char*>(videoPacket2.data()), videoPacket2.size());
        std::ostringstream payload;
        payload.write(reinterpret_cast<const char*>(videoPayload1.data()), videoPayload1.size());
        payload.write(reinterpret_cast<const char*>(videoPayload2.data()), videoPayload2.size());
        failures += 1 - runTest("readAll_Video2Packets_OK", input, Error::OK, payload.str(), 1);
    }

    // 3 video packets, start of TS is not start of ES
    {
        std::stringstream input;
        input.write(reinterpret_cast<const char*>(videoPacket3.data()), videoPacket3.size());
        input.write(reinterpret_cast<const char*>(videoPacket1.data()), videoPacket1.size());
        input.write(reinterpret_cast<const char*>(videoPacket2.data()), videoPacket2.size());
        std::ostringstream payload;
        payload.write(reinterpret_cast<const char*>(videoPayload1.data()), videoPayload1.size());
        payload.write(reinterpret_cast<const char*>(videoPayload2.data()), videoPayload2.size());
        failures += 1 - runTest("readAll_TsStartNotEsStart_OK", input, Error::OK, payload.str(), 1);
    }

    // PAT packet and video packet
    {
        std::stringstream input;
        input.write(reinterpret_cast<const char*>(patPacket.data()), patPacket.size());
        input.write(reinterpret_cast<const char*>(videoPacket1.data()), videoPacket1.size());
        std::ostringstream payload;
        payload.write(reinterpret_cast<const char*>(patPayload.data()), patPayload.size());
        payload.write(reinterpret_cast<const char*>(videoPayload1.data()), videoPayload1.size());
        failures += 1 - runTest("readAll_PatAndVideoPackets_OK", input, Error::OK, payload.str(), 2);
    }

    // null packet and video packet
    {
        std::stringstream input;
        input.write(reinterpret_cast<const char*>(nullPacket.data()), nullPacket.size());
        input.write(reinterpret_cast<const char*>(videoPacket1.data()), videoPacket1.size());
        std::ostringstream payload;
        payload.write(reinterpret_cast<const char*>(videoPayload1.data()), videoPayload1.size());
        failures += 1 - runTest("readAll_NullAndVideoPackets_OK", input, Error::OK, payload.str(), 1);
    }

    // 1 audio packet, start of elementary stream
    {
        std::stringstream input;
        input.write(reinterpret_cast<const char*>(audioPacket1.data()), audioPacket1.size());
        std::ostringstream payload;
        payload.write(reinterpret_cast<const char*>(audioPayload1.data()), audioPayload1.size());
        failures += 1 - runTest("readAll_Audio1Packet_OK", input, Error::OK, payload.str(), 1);
    }

    // 2 audio packets, start of elementary stream and continuation
    {
        std::stringstream input;
        input.write(reinterpret_cast<const char*>(audioPacket1.data()), audioPacket1.size());
        input.write(reinterpret_cast<const char*>(audioPacket2.data()), audioPacket2.size());
        std::ostringstream payload;
        payload.write(reinterpret_cast<const char*>(audioPayload1.data()), audioPayload1.size());
        payload.write(reinterpret_cast<const char*>(audioPayload2.data()), audioPayload2.size());
        failures += 1 - runTest("readAll_Audio2Packets_OK", input, Error::OK, payload.str(), 1);
    }

    // 2 elementary streams
    {
        std::stringstream input;
        input.write(reinterpret_cast<const char*>(videoPacket1.data()), videoPacket1.size());
        input.write(reinterpret_cast<const char*>(audioPacket1.data()), audioPacket1.size());
        input.write(reinterpret_cast<const char*>(videoPacket2.data()), videoPacket2.size());
        input.write(reinterpret_cast<const char*>(audioPacket2.data()), audioPacket2.size());
        std::ostringstream payload;
        payload.write(reinterpret_cast<const char*>(videoPayload1.data()), videoPayload1.size());
        payload.write(reinterpret_cast<const char*>(audioPayload1.data()), audioPayload1.size());
        payload.write(reinterpret_cast<const char*>(videoPayload2.data()), videoPayload2.size());
        payload.write(reinterpret_cast<const char*>(audioPayload2.data()), audioPayload2.size());
        failures += 1 - runTest("readAll_AudioAndVideoPackets_OK", input, Error::OK, payload.str(), 2);
    }

    // short input
    {
        std::stringstream input;
        input.write(reinterpret_cast<const char*>(videoPacket3.data() + 10), videoPacket3.size() / 2);
        failures += 1 - runTest("readAll_ShortInput_OK", input, Error::OK, "", 0);
    }

    // empty input
    {
        std::stringstream input;
        failures += 1 - runTest("readAll_EmptyInput_OK", input, Error::OK, "", 0);
    }

    // not a TS stream
    {
        std::stringstream input;
        input.write(reinterpret_cast<const char*>(videoPacket3.data() + 10), videoPacket3.size() - 20);
        input.write(reinterpret_cast<const char*>(videoPacket1.data() + 10), videoPacket1.size() - 20);
        failures += 1 - runTest("readAll_NotTsStream_OK", input, Error::OK, "", 0);
    }

    // corrupted TS start with sync byte
    {
        std::stringstream input;
        input.write(reinterpret_cast<const char*>(videoPacket3.data()), videoPacket3.size() / 2);
        input.write(reinterpret_cast<const char*>(videoPacket1.data()), videoPacket1.size());
        input.write(reinterpret_cast<const char*>(videoPacket2.data()), videoPacket2.size());
        std::ostringstream payload;
        payload.write(reinterpret_cast<const char*>(videoPayload1.data()), videoPayload1.size());
        payload.write(reinterpret_cast<const char*>(videoPayload2.data()), videoPayload2.size());
        failures += 1 - runTest("readAll_CorruptedTsStartWithSyncByte_OK", input, Error::OK, payload.str(), 1);
    }

    // corrupted TS start without sync byte
    {
        std::stringstream input;
        input.write(reinterpret_cast<const char*>(videoPacket3.data() + 10), videoPacket3.size() / 2);
        input.write(reinterpret_cast<const char*>(videoPacket1.data()), videoPacket1.size());
        input.write(reinterpret_cast<const char*>(videoPacket2.data()), videoPacket2.size());
        std::ostringstream payload;
        payload.write(reinterpret_cast<const char*>(videoPayload1.data()), videoPayload1.size());
        payload.write(reinterpret_cast<const char*>(videoPayload2.data()), videoPayload2.size());
        failures += 1 - runTest("readAll_CorruptedTsStartWithoutSyncByte_OK", input, Error::OK, payload.str(), 1);
    }

    // corrupted TS end with sync byte
    {
        std::stringstream input;
        input.write(reinterpret_cast<const char*>(videoPacket1.data()), videoPacket1.size());
        input.write(reinterpret_cast<const char*>(audioPacket1.data()), audioPacket1.size());
        input.write(reinterpret_cast<const char*>(videoPacket2.data()), videoPacket2.size() / 2);
        std::ostringstream payload;
        payload.write(reinterpret_cast<const char*>(videoPayload1.data()), videoPayload1.size());
        payload.write(reinterpret_cast<const char*>(audioPayload1.data()), audioPayload1.size());
        failures += 1 - runTest("readAll_CorruptedTsEndWithSyncByte_OK", input, Error::OK, payload.str(), 2);
    }

    // corrupted TS end without sync byte, last packet preceeding garbage is lost
    {
        std::stringstream input;
        input.write(reinterpret_cast<const char*>(videoPacket1.data()), videoPacket1.size());
        input.write(reinterpret_cast<const char*>(audioPacket1.data()), audioPacket1.size());
        input.write(reinterpret_cast<const char*>(videoPacket2.data() + 10), videoPacket2.size() / 2);
        std::ostringstream payload;
        payload.write(reinterpret_cast<const char*>(videoPayload1.data()), videoPayload1.size());
        failures += 1 - runTest("readAll_CorruptedTsEndWithoutSyncByte_OK", input, Error::OK, payload.str(), 1);
    }

    // corrupted TS middle with sync byte
    {
        std::stringstream input;
        input.write(reinterpret_cast<const char*>(videoPacket1.data()), videoPacket1.size());
        input.write(reinterpret_cast<const char*>(videoPacket3.data()), videoPacket3.size() / 2);
        input.write(reinterpret_cast<const char*>(videoPacket2.data()), videoPacket2.size());
        std::ostringstream payload;
        payload.write(reinterpret_cast<const char*>(videoPayload1.data()), videoPayload1.size());
        payload.write(reinterpret_cast<const char*>(videoPayload2.data()), videoPayload2.size());
        failures += 1 - runTest("readAll_CorruptedTsMiddleWithSyncByte_OK", input, Error::OK, payload.str(), 1);
    }

    // corrupted TS middle without sync byte, last packet preceeding garbage is lost
    {
        std::stringstream input;
        input.write(reinterpret_cast<const char*>(videoPacket1.data()), videoPacket1.size());
        input.write(reinterpret_cast<const char*>(videoPacket3.data() + 10), videoPacket3.size() / 2);
        input.write(reinterpret_cast<const char*>(videoPacket2.data()), videoPacket2.size());
        failures += 1 - runTest("readAll_CorruptedTsMiddleWithoutSyncByte_OK", input, Error::OK, "", 0);
    }

    return failures;
}
